#####################################
# Akka Remote Reference Config File #
#####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your akka.conf.

# comments about akka.actor settings left out where they are already in akka-
# actor.jar, because otherwise they would be repeated in config rendering.

channel-dispatcher {
  mailbox-type = "com.vilenet.channels.ChannelMailbox"
  //Other dispatcher configuration goes here
}

akka {

  loggers = ["akka.event.slf4j.Slf4jLogger"]
  loglevel = "INFO"
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

  extensions = [
    "akka.cluster.pubsub.DistributedPubSub"
    "com.romix.akka.serialization.kryo.KryoSerializationExtension$"
  ]

  actor {

    provider = "akka.cluster.ClusterActorRefProvider"

    kryo  {
      # Possibles values for type are: graph or nograph
      # graph supports serialization of object graphs with shared nodes
      # and cyclic references, but this comes at the expense of a small
      # overhead nograph does not support object grpahs with shared nodes,
      # but is usually faster
      type = "nograph"

      # Possible values for idstrategy are:
      # default, explicit, incremental
      #
      # default - slowest and produces bigger serialized representation.
      # Contains fully-qualified class names (FQCNs) for each class. Note
      # that selecting this strategy does not work in version 0.3.2, but
      # is available on master and from 0.3.3 onward.
      #
      # explicit - fast and produces compact serialized representation.
      # Requires that all classes that will be serialized are pre-registered
      # using the "mappings" and "classes" sections. To guarantee that both
      # sender and receiver use the same numeric ids for the same classes it
      # is advised to provide exactly the same entries in the "mappings"
      # section.
      #
      # incremental - fast and produces compact serialized representation.
      # Support optional pre-registering of classes using the "mappings"
      # and "classes" sections. If class is not pre-registered, it will be
      # registered dynamically by picking a next available id To guarantee
      # that both sender and receiver use the same numeric ids for the same
      # classes it is advised to pre-register them using at least the "classes" section.
      idstrategy = "default"

      # Define a default size for serializer pool
      # Try to define the size to be at least as big as the max possible
      # number of threads that may be used for serialization, i.e. max
      # number of threads allowed for the scheduler
      serializer-pool-size = 16

      # Define a default size for byte buffers used during serialization
      buffer-size = 2048

      # The serialization byte buffers are doubled as needed until they
      # exceed max-buffer-size and an exception is thrown. Can be -1
      # for no maximum.
      max-buffer-size = -1

      # If set, akka uses manifests to put a class name
      # of the top-level object into each message
      use-manifests = false

      # The transformations that have be done while serialization
      # Supported transformations: compression and encryption
      # accepted values(comma separated if multiple): off | lz4 | deflate | aes
      # Transformations occur in the order they are specified
      post-serialization-transformations = "off"

      # Settings for aes encryption, if included in transformations AES
      # algo mode, key and custom key class can be specified AES algo mode
      # defaults to 'AES/CBC/PKCS5Padding' and key to 'ThisIsASecretKey'.
      # If custom key class is provided, Kryo will use the class specified
      # by a fully qualified class name to get custom AES key. Such a
      # class should define the method 'kryoAESKey'. This key overrides 'key'.
      # If class doesn't contain 'kryoAESKey' method, specified key is used.
      # If this is not present, default key is used
      #encryption {
      #  aes {
      #    mode = "AES/CBC/PKCS5Padding"
      #    key = j68KkRjq21ykRGAQ
      #    custom-key-class = "CustomAESKeyClass"
      #  }
      #}

      # Log implicitly registered classes. Useful, if you want to know all
      # classes which are serialized. You can then use this information in
      # the mappings and/or classes sections
      implicit-registration-logging = false

      # If enabled, Kryo logs a lot of information about serialization process.
      # Useful for debugging and lowl-level tweaking
      kryo-trace = false

      # If proviced, Kryo uses the class specified by a fully qualified
      # class name to perform a custom initialization of Kryo instances in
      # addition to what is done automatically based on the config file.
      #kryo-custom-serializer-init = "CustomKryoSerializerInitFQCN"

      # Define mappings from a fully qualified class name to a numeric id.
      # Smaller ids lead to smaller sizes of serialized representations.
      #
      # This section is mandatory for idstartegy=explicit
      # This section is optional  for idstartegy=incremental
      # This section is ignored   for idstartegy=default
      #
      # The smallest possible id should start at 20 (or even higher), because
      # ids below it are used by Kryo internally e.g. for built-in Java and
      # Scala types
      mappings {
        "com.vilenet.coders.commands.ChannelCommand" = 29
        "com.vilenet.coders.commands.UserCommand" = 30
        "com.vilenet.coders.commands.UserToChannelCommand" = 31
        "com.vilenet.coders.commands.OperableCommand" = 32
        "com.vilenet.coders.commands.ReturnableCommand" = 33
        "com.vilenet.coders.commands.ChannelsCommand" = 34
        "com.vilenet.coders.commands.TopCommand" = 35
        "com.vilenet.coders.commands.WhoisCommand" = 36
        "com.vilenet.coders.commands.AwayCommand" = 37
        "com.vilenet.coders.commands.DndCommand" = 38
        "com.vilenet.coders.commands.WhoCommand" = 39
        "com.vilenet.coders.commands.WhoCommandToChannel" = 40
        "com.vilenet.servers.SendBirth$" = 41
        "com.vilenet.servers.ServerOnline" = 42
        "com.vilenet.servers.ServerOnline$" = 62

        "com.vilenet.servers.ServerOffline" = 43
        "com.vilenet.servers.ServerOnlineAck$" = 44
        "com.vilenet.servers.ServerOffline$" = 45
        "com.vilenet.servers.AddListener$" = 46
        "com.vilenet.servers.SplitMe$" = 47

        "com.vilenet.users.Add" = 48
        "com.vilenet.users.Rem" = 49
        "com.vilenet.users.WhisperTo" = 50
        "com.vilenet.users.GetUsers$" = 51
        "com.vilenet.users.ReceivedUser" = 52
        "com.vilenet.users.ReceivedUsers" = 53
        "com.vilenet.users.UserToChannelCommandAck" = 54
        "com.vilenet.users.UsersUserAdded" = 55

        "com.vilenet.channels.GetChannels" = 56
        "com.vilenet.channels.ChannelCreated" = 57
        "com.vilenet.channels.GetChannelUsers" = 58
        "com.vilenet.channels.ReceivedChannel" = 59
        "com.vilenet.channels.UserAdded" = 60

        "com.vilenet.servers.RemoteEvent" = 61
        "akka.actor.ActorSelectionMessage" = 63
        "akka.remote.DaemonMsgCreate" = 64
        "akka.dispatch.sysmsg.SystemMessage" = 65
        "akka.remote.RemoteWatcher" = 66
        "akka.actor.ActorRef" = 67
        "akka.actor.LocalActorRef" = 68
        "akka.remote.RemoteActorRef" = 69
        "com.vilenet.utils.RealKeyedCaseInsensitiveHashMap" = 70
        "com.vilenet.users.BinaryProtocol" = 71
        "com.vilenet.users.TelnetProtocol" = 72
        "com.vilenet.channels.User" = 73
        "com.vilenet.channels.ChannelUsersLoad" = 74

        "scala.collection.mutable.LinkedHashMap" = 75
        "com.vilenet.channels.utils.LocalUsersSet" = 76
        "com.vilenet.channels.AddUser" = 77
        "com.vilenet.channels.RemUser" = 78
        "com.vilenet.coders.commands.ChatCommand" = 79
        "com.vilenet.coders.commands.EmoteCommand" = 80
        "com.vilenet.channels.ChannelUsersRequest" = 81
        "com.vilenet.channels.ChannelUsersResponse" = 82
        "scala.Tuple2" = 90
      }

      kryo-reference-map = false

      # Define a set of fully qualified class names for
      # classes to be used for serialization.
      # The ids for those classes will be assigned automatically,
      # but respecting the order of declaration in this section
      #
      # This section is optional  for idstartegy=incremental
      # This section is ignored   for idstartegy=default
      # This section is optional  for idstartegy=explicit
      classes = [
        "akka.actor.ActorRef"
        "akka.actor.LocalActorRef"
        "akka.remote.RemoteActorRef"
        "com.vilenet.utils.RealKeyedCaseInsensitiveHashMap"
        "com.vilenet.users.BinaryProtocol$"
        "com.vilenet.users.TelnetProtocol$"
        "com.vilenet.channels.User"
        "com.vilenet.channels.ChannelUsersLoad"
        "scala.collection.mutable.LinkedHashMap"
        "com.vilenet.channels.utils.LocalUsersSet"

        "com.vilenet.coders.commands.ChatCommand"
        "com.vilenet.coders.commands.EmoteCommand"
        "com.vilenet.coders.commands.ChannelCommand"
        "com.vilenet.coders.commands.UserCommand"
        "com.vilenet.coders.commands.UserToChannelCommand"
        "com.vilenet.coders.commands.OperableCommand"
        "com.vilenet.coders.commands.ReturnableCommand"
        "com.vilenet.coders.commands.ChannelsCommand"
        "com.vilenet.coders.commands.TopCommand"
        "com.vilenet.coders.commands.WhoisCommand"
        "com.vilenet.coders.commands.AwayCommand"
        "com.vilenet.coders.commands.DndCommand"
        "com.vilenet.coders.commands.WhoCommand"
        "com.vilenet.coders.commands.WhoCommandToChannel"

        "com.vilenet.servers.SendBirth"
        "com.vilenet.servers.SendBirth$"
        "com.vilenet.servers.ServerOnline"
        "com.vilenet.servers.ServerOnline$"
        "com.vilenet.servers.ServerOffline"
        "com.vilenet.servers.ServerOffline$"
        "com.vilenet.servers.ServerOnlineAck"
        "com.vilenet.servers.ServerOnlineAck$"
        "com.vilenet.servers.AddListener$"
        "com.vilenet.servers.SplitMe$"

        "com.vilenet.users.Add"
        "com.vilenet.users.Rem"
        "com.vilenet.users.WhisperTo"
        "com.vilenet.users.GetUsers"
        "com.vilenet.users.GetUsers$"
        "com.vilenet.users.ReceivedUser"
        "com.vilenet.users.ReceivedUsers"
        "com.vilenet.users.UserToChannelCommandAck"
        "com.vilenet.users.UsersUserAdded"

        "com.vilenet.channels.AddUser"
        "com.vilenet.channels.RemUser"
        "com.vilenet.channels.GetChannels"
        "com.vilenet.channels.ChannelCreated"
        "com.vilenet.channels.GetChannelUsers"
        "com.vilenet.channels.ReceivedChannel"
        "com.vilenet.channels.UserAdded"
        "com.vilenet.channels.ChannelUsersRequest"
        "com.vilenet.channels.ChannelUsersResponse"

        "com.vilenet.servers.RemoteEvent"
        "scala.Tuple2"
      ]
    }

    serializers {
      java = "akka.serialization.JavaSerializer"
      akka-containers = "akka.remote.serialization.MessageContainerSerializer"
      akka-cluster = "akka.cluster.protobuf.ClusterMessageSerializer"
      akka-pubsub = "akka.cluster.pubsub.protobuf.DistributedPubSubMessageSerializer"
      daemon-create = "akka.remote.serialization.DaemonMsgCreateSerializer"
      kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
    }

    serialization-bindings {
      "java.io.Serializable" = none
      "akka.actor.ActorSelectionMessage" = akka-containers
      "akka.remote.DaemonMsgCreate" = daemon-create
      "akka.cluster.ClusterMessage" = akka-cluster
      "akka.cluster.pubsub.DistributedPubSubMessage" = akka-pubsub
      "akka.dispatch.sysmsg.SystemMessage" = java
      "com.vilenet.coders.commands.Command" = kryo

      "com.vilenet.utils.RealKeyedCaseInsensitiveHashMap" = kryo
      "scala.collection.mutable.Map" = kryo
      "scala.collection.mutable.Set" = kryo
      "akka.actor.ActorRef" = kryo
      "scala.Tuple2" = kryo

      # Since akka.protobuf.Message does not extend Serializable but
      # GeneratedMessage does, need to use the more specific one here in order
      # to avoid ambiguity.
      #"akka.protobuf.GeneratedMessage" = proto

      # Since com.google.protobuf.Message does not extend Serializable but
      # GeneratedMessage does, need to use the more specific one here in order
      # to avoid ambiguity.
      # This com.google.protobuf serialization binding is only used if the class can be loaded,
      # i.e. com.google.protobuf dependency has been added in the application project.
      #"com.google.protobuf.GeneratedMessage" = proto
    }

    serialization-identifiers {
      "akka.remote.serialization.DaemonMsgCreateSerializer" = 20
      "akka.remote.serialization.MessageContainerSerializer" = 21
      "akka.cluster.protobuf.ClusterMessageSerializer" = 22
      "akka.cluster.pubsub.protobuf.DistributedPubSubMessageSerializer" = 23
      "com.romix.akka.serialization.kryo.KryoSerializer" = 24
    }

    deployment {

      default {

        # if this is set to a valid remote address, the named actor will be
        # deployed at that node e.g. "akka.tcp://sys@host:port"
        remote = ""

        cluster {
          # enable cluster aware router that deploys to nodes in the cluster
          enabled = off

          # Maximum number of routees that will be deployed on each cluster
          # member node.
          # Note that max-total-nr-of-instances defines total number of routees, but
          # number of routees per node will not be exceeded, i.e. if you
          # define max-total-nr-of-instances = 50 and max-nr-of-instances-per-node = 2
          # it will deploy 2 routees per new member in the cluster, up to
          # 25 members.
          max-nr-of-instances-per-node = 1

          # Maximum number of routees that will be deployed, in total
          # on all nodes. See also description of max-nr-of-instances-per-node.
          # For backwards compatibility reasons, nr-of-instances
          # has the same purpose as max-total-nr-of-instances for cluster
          # aware routers and nr-of-instances (if defined by user) takes
          # precedence over max-total-nr-of-instances.
          max-total-nr-of-instances = 10000

          # Defines if routees are allowed to be located on the same node as
          # the head router actor, or only on remote nodes.
          # Useful for master-worker scenario where all routees are remote.
          allow-local-routees = on

          # Use members with specified role, or all members if undefined or empty.
          use-role = ""

        }

        target {

          # A list of hostnames and ports for instantiating the children of a
          # router
          #   The format should be on "akka.tcp://sys@host:port", where:
          #    - sys is the remote actor system name
          #    - hostname can be either hostname or IP address the remote actor
          #      should connect to
          #    - port should be the port for the remote server on the other node
          # The number of actor instances to be spawned is still taken from the
          # nr-of-instances setting as for local routers; the instances will be
          # distributed round-robin among the given nodes.
          nodes = []

        }
      }
    }
  }

  cluster {
    # Initial contact points of the cluster.
    # The nodes to join automatically at startup.
    # Comma separated full URIs defined by a string on the form of
    # "akka.tcp://system@hostname:port"
    # Leave as empty if the node is supposed to be joined manually.
    seed-nodes = [
      "akka.tcp://ViLeNet@127.0.0.1:2552"
      "akka.tcp://ViLeNet@127.0.0.1:2553"
      "akka.tcp://ViLeNet@127.0.0.1:2554"
      #"akka.tcp://ViLeNet@172.31.9.79:2552"
      #"akka.tcp://ViLeNet@172.31.9.79:2553"
    ]

    # how long to wait for one of the seed nodes to reply to initial join request
    seed-node-timeout = 5s

    # If a join request fails it will be retried after this period.
    # Disable join retry by specifying "off".
    retry-unsuccessful-join-after = 10s

    # Should the 'leader' in the cluster be allowed to automatically mark
    # unreachable nodes as DOWN after a configured time of unreachability?
    # Using auto-down implies that two separate clusters will automatically be
    # formed in case of network partition.
    # Disable with "off" or specify a duration to enable auto-down.
    auto-down-unreachable-after = off

    # Time margin after which shards or singletons that belonged to a downed/removed
    # partition are created in surviving partition. The purpose of this margin is that
    # in case of a network partition the persistent actors in the non-surviving partitions
    # must be stopped before corresponding persistent actors are started somewhere else.
    # This is useful if you implement downing strategies that handle network partitions,
    # e.g. by keeping the larger side of the partition and shutting down the smaller side.
    # It will not add any extra safety for auto-down-unreachable-after, since that is not
    # handling network partitions.
    # Disable with "off" or specify a duration to enable.
    down-removal-margin = off

    # By default, the leader will not move 'Joining' members to 'Up' during a network
    # split. This feature allows the leader to accept 'Joining' members to be 'WeaklyUp'
    # so they become part of the cluster even during a network split. The leader will
    # move 'WeaklyUp' members to 'Up' status once convergence has been reached. This
    # feature must be off if some members are running Akka 2.3.X.
    # WeaklyUp is an EXPERIMENTAL feature.
    allow-weakly-up-members = off

    # The roles of this member. List of strings, e.g. roles = ["A", "B"].
    # The roles are part of the membership information and can be used by
    # routers or other services to distribute work to certain member types,
    # e.g. front-end and back-end nodes.
    roles = []

    role {
      # Minimum required number of members of a certain role before the leader
      # changes member status of 'Joining' members to 'Up'. Typically used together
      # with 'Cluster.registerOnMemberUp' to defer some action, such as starting
      # actors, until the cluster has reached a certain size.
      # E.g. to require 2 nodes with role 'frontend' and 3 nodes with role 'backend':
      #   frontend.min-nr-of-members = 2
      #   backend.min-nr-of-members = 3
      #<role-name>.min-nr-of-members = 1
    }

    # Minimum required number of members before the leader changes member status
    # of 'Joining' members to 'Up'. Typically used together with
    # 'Cluster.registerOnMemberUp' to defer some action, such as starting actors,
    # until the cluster has reached a certain size.
    min-nr-of-members = 1

    # Enable/disable info level logging of cluster events
    log-info = on

    # Enable or disable JMX MBeans for management of the cluster
    jmx.enabled = on

    # how long should the node wait before starting the periodic tasks
    # maintenance tasks?
    periodic-tasks-initial-delay = 1s

    # how often should the node send out gossip information?
    gossip-interval = 1s

    # discard incoming gossip messages if not handled within this duration
    gossip-time-to-live = 2s

    # how often should the leader perform maintenance tasks?
    leader-actions-interval = 1s

    # how often should the node move nodes, marked as unreachable by the failure
    # detector, out of the membership ring?
    unreachable-nodes-reaper-interval = 1s

    # How often the current internal stats should be published.
    # A value of 0s can be used to always publish the stats, when it happens.
    # Disable with "off".
    publish-stats-interval = off

    # The id of the dispatcher to use for cluster actors. If not specified
    # default dispatcher is used.
    # If specified you need to define the settings of the actual dispatcher.
    use-dispatcher = ""

    # Gossip to random node with newer or older state information, if any with
    # this probability. Otherwise Gossip to any random live node.
    # Probability value is between 0.0 and 1.0. 0.0 means never, 1.0 means always.
    gossip-different-view-probability = 0.8

    # Reduced the above probability when the number of nodes in the cluster
    # greater than this value.
    reduce-gossip-different-view-probability = 400

    # Settings for the Phi accrual failure detector (http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf
    # [Hayashibara et al]) used by the cluster subsystem to detect unreachable
    # members.
    # The default PhiAccrualFailureDetector will trigger if there are no heartbeats within
    # the duration heartbeat-interval + acceptable-heartbeat-pause + threshold_adjustment,
    # i.e. around 5.5 seconds with default settings.
    failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = "akka.remote.PhiAccrualFailureDetector"

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 1 s

      # Defines the failure detector threshold.
      # A low threshold is prone to generate many wrong suspicions but ensures
      # a quick detection in the event of a real crash. Conversely, a high
      # threshold generates fewer mistakes but needs more time to detect
      # actual crashes.
      threshold = 8.0

      # Number of the samples of inter-heartbeat arrival times to adaptively
      # calculate the failure timeout for connections.
      max-sample-size = 1000

      # Minimum standard deviation to use for the normal distribution in
      # AccrualFailureDetector. Too low standard deviation might result in
      # too much sensitivity for sudden, but normal, deviations in heartbeat
      # inter arrival times.
      min-std-deviation = 100 ms

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # This margin is important to be able to survive sudden, occasional,
      # pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 3 s

      # Number of member nodes that each member will send heartbeat messages to,
      # i.e. each node will be monitored by this number of other nodes.
      monitored-by-nr-of-members = 5

      # After the heartbeat request has been sent the first failure detection
      # will start after this period, even though no heartbeat message has
      # been received.
      expected-response-after = 1 s

    }

    metrics {
      # Enable or disable metrics collector for load-balancing nodes.
      enabled = off

      # FQCN of the metrics collector implementation.
      # It must implement akka.cluster.MetricsCollector and
      # have public constructor with akka.actor.ActorSystem parameter.
      # The default SigarMetricsCollector uses JMX and Hyperic SIGAR, if SIGAR
      # is on the classpath, otherwise only JMX.
      collector-class = "akka.cluster.SigarMetricsCollector"

      # How often metrics are sampled on a node.
      # Shorter interval will collect the metrics more often.
      collect-interval = 3s

      # How often a node publishes metrics information.
      gossip-interval = 3s

      # How quickly the exponential weighting of past data is decayed compared to
      # new data. Set lower to increase the bias toward newer values.
      # The relevance of each data sample is halved for every passing half-life
      # duration, i.e. after 4 times the half-life, a data sample’s relevance is
      # reduced to 6% of its original relevance. The initial relevance of a data
      # sample is given by 1 – 0.5 ^ (collect-interval / half-life).
      # See http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
      moving-average-half-life = 12s
    }

    # If the tick-duration of the default scheduler is longer than the
    # tick-duration configured here a dedicated scheduler will be used for
    # periodic tasks of the cluster, otherwise the default scheduler is used.
    # See akka.scheduler settings for more details.
    scheduler {
      tick-duration = 33ms
      ticks-per-wheel = 512
    }

    pub-sub {
      # Actor name of the mediator actor, /system/distributedPubSubMediator
      name = distributedPubSubMediator

      # Start the mediator on members tagged with this role.
      # All members are used if undefined or empty.
      role = ""

      # The routing logic to use for 'Send'
      # Possible values: random, round-robin, broadcast
      routing-logic = random

      # How often the DistributedPubSubMediator should send out gossip information
      gossip-interval = 1s

      # Removed entries are pruned after this duration
      removed-time-to-live = 120s

      # Maximum number of elements to transfer in one message when synchronizing the registries.
      # Next chunk will be transferred in next round of gossip.
      max-delta-elements = 3000

      # The id of the dispatcher to use for DistributedPubSubMediator actors.
      # If not specified default dispatcher is used.
      # If specified you need to define the settings of the actual dispatcher.
      use-dispatcher = ""

    }
  }

  remote {

    ### General settings

    # Timeout after which the startup of the remoting subsystem is considered
    # to be failed. Increase this value if your transport drivers (see the
    # enabled-transports section) need longer time to be loaded.
    startup-timeout = 10 s

    # Timout after which the graceful shutdown of the remoting subsystem is
    # considered to be failed. After the timeout the remoting system is
    # forcefully shut down. Increase this value if your transport drivers
    # (see the enabled-transports section) need longer time to stop properly.
    shutdown-timeout = 10 s

    # Before shutting down the drivers, the remoting subsystem attempts to flush
    # all pending writes. This setting controls the maximum time the remoting is
    # willing to wait before moving on to shut down the drivers.
    flush-wait-on-shutdown = 2 s

    # Reuse inbound connections for outbound messages
    use-passive-connections = on

    # Controls the backoff interval after a refused write is reattempted.
    # (Transports may refuse writes if their internal buffer is full)
    backoff-interval = 5 ms

    # Acknowledgment timeout of management commands sent to the transport stack.
    command-ack-timeout = 30 s

    # If set to a nonempty string remoting will use the given dispatcher for
    # its internal actors otherwise the default dispatcher is used. Please note
    # that since remoting can load arbitrary 3rd party drivers (see
    # "enabled-transport" and "adapters" entries) it is not guaranteed that
    # every module will respect this setting.
    use-dispatcher = "akka.remote.default-remote-dispatcher"

    ### Security settings

    # Enable untrusted mode for full security of server managed actors, prevents
    # system messages to be send by clients, e.g. messages like 'Create',
    # 'Suspend', 'Resume', 'Terminate', 'Supervise', 'Link' etc.
    untrusted-mode = off

    # When 'untrusted-mode=on' inbound actor selections are by default discarded.
    # Actors with paths defined in this white list are granted permission to receive actor
    # selections messages.
    # E.g. trusted-selection-paths = ["/user/receptionist", "/user/namingService"]
    trusted-selection-paths = []

    # Should the remote server require that its peers share the same
    # secure-cookie (defined in the 'remote' section)? Secure cookies are passed
    # between during the initial handshake. Connections are refused if the initial
    # message contains a mismatching cookie or the cookie is missing.
    require-cookie = off

    # Deprecated since 2.4-M1
    secure-cookie = ""

    ### Logging

    # If this is "on", Akka will log all inbound messages at DEBUG level,
    # if off then they are not logged
    log-received-messages = off

    # If this is "on", Akka will log all outbound messages at DEBUG level,
    # if off then they are not logged
    log-sent-messages = off

    # Sets the log granularity level at which Akka logs remoting events. This setting
    # can take the values OFF, ERROR, WARNING, INFO, DEBUG, or ON. For compatibility
    # reasons the setting "on" will default to "debug" level. Please note that the effective
    # logging level is still determined by the global logging level of the actor system:
    # for example debug level remoting events will be only logged if the system
    # is running with debug level logging.
    # Failures to deserialize received messages also fall under this flag.
    log-remote-lifecycle-events = on

    # Logging of message types with payload size in bytes larger than
    # this value. Maximum detected size per message type is logged once,
    # with an increase threshold of 10%.
    # By default this feature is turned off. Activate it by setting the property to
    # a value in bytes, such as 1000b. Note that for all messages larger than this
    # limit there will be extra performance and scalability cost.
    log-frame-size-exceeding = off

    # Log warning if the number of messages in the backoff buffer in the endpoint
    # writer exceeds this limit. It can be disabled by setting the value to off.
    log-buffer-size-exceeding = 50000

    ### Failure detection and recovery

    # Settings for the failure detector to monitor connections.
    # For TCP it is not important to have fast failure detection, since
    # most connection failures are captured by TCP itself.
    # The default DeadlineFailureDetector will trigger if there are no heartbeats within
    # the duration heartbeat-interval + acceptable-heartbeat-pause, i.e. 20 seconds
    # with the default settings.
    transport-failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = "akka.remote.DeadlineFailureDetector"

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 4 s

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # A margin to the `heartbeat-interval` is important to be able to survive sudden,
      # occasional, pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 16 s
    }

    # Settings for the Phi accrual failure detector (http://ddg.jaist.ac.jp/pub/HDY+04.pdf
    # [Hayashibara et al]) used for remote death watch.
    # The default PhiAccrualFailureDetector will trigger if there are no heartbeats within
    # the duration heartbeat-interval + acceptable-heartbeat-pause + threshold_adjustment,
    # i.e. around 12.5 seconds with default settings.
    watch-failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = "akka.remote.PhiAccrualFailureDetector"

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 2 s

      # Defines the failure detector threshold.
      # A low threshold is prone to generate many wrong suspicions but ensures
      # a quick detection in the event of a real crash. Conversely, a high
      # threshold generates fewer mistakes but needs more time to detect
      # actual crashes.
      threshold = 10.0

      # Number of the samples of inter-heartbeat arrival times to adaptively
      # calculate the failure timeout for connections.
      max-sample-size = 200

      # Minimum standard deviation to use for the normal distribution in
      # AccrualFailureDetector. Too low standard deviation might result in
      # too much sensitivity for sudden, but normal, deviations in heartbeat
      # inter arrival times.
      min-std-deviation = 100 ms

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # This margin is important to be able to survive sudden, occasional,
      # pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 10 s


      # How often to check for nodes marked as unreachable by the failure
      # detector
      unreachable-nodes-reaper-interval = 1 s

      # After the heartbeat request has been sent the first failure detection
      # will start after this period, even though no heartbeat mesage has
      # been received.
      expected-response-after = 2 s

    }

    # After failed to establish an outbound connection, the remoting will mark the
    # address as failed. This configuration option controls how much time should
    # be elapsed before reattempting a new connection. While the address is
    # gated, all messages sent to the address are delivered to dead-letters.
    # Since this setting limits the rate of reconnects setting it to a
    # very short interval (i.e. less than a second) may result in a storm of
    # reconnect attempts.
    retry-gate-closed-for = 30 s

    # If system messages have been exchanged between two systems (i.e. remote death
    # watch or remote deployment has been used) a remote system will be marked as
    # quarantined after the two system has no active association, and no
    # communication happens during the time configured here.
    # The only purpose of this setting is to avoid storing system message redelivery
    # data (sequence number state, etc.) for an undefined amount of time leading to long
    # term memory leak. Instead, if a system has been gone for this period,
    # or more exactly
    # - there is no association between the two systems (TCP connection, if TCP transport is used)
    # - neither side has been attempting to communicate with the other
    # - there are no pending system messages to deliver
    # for the amount of time configured here, the remote system will be quarantined and all state
    # associated with it will be dropped.
    quarantine-after-silence = 5 d

    # After catastrophic communication failures that result in the loss of system
    # messages or after the remote DeathWatch triggers the remote system gets
    # quarantined to prevent inconsistent behavior.
    # This setting controls how long the Quarantine marker will be kept around
    # before being removed to avoid long-term memory leaks.
    # WARNING: DO NOT change this to a small value to re-enable communication with
    # quarantined nodes. Such feature is not supported and any behavior between
    # the affected systems after lifting the quarantine is undefined.
    prune-quarantine-marker-after = 5 d

    # This setting defines the maximum number of unacknowledged system messages
    # allowed for a remote system. If this limit is reached the remote system is
    # declared to be dead and its UID marked as tainted.
    system-message-buffer-size = 500000

    # This setting defines the maximum idle time after an individual
    # acknowledgement for system messages is sent. System message delivery
    # is guaranteed by explicit acknowledgement messages. These acks are
    # piggybacked on ordinary traffic messages. If no traffic is detected
    # during the time period configured here, the remoting will send out
    # an individual ack.
    system-message-ack-piggyback-timeout = 0.3 s

    # This setting defines the time after internal management signals
    # between actors (used for DeathWatch and supervision) that have not been
    # explicitly acknowledged or negatively acknowledged are resent.
    # Messages that were negatively acknowledged are always immediately
    # resent.
    resend-interval = 2 s

    # Maximum number of unacknowledged system messages that will be resent
    # each 'resend-interval'. If you watch many (> 1000) remote actors you can
    # increase this value to for example 600, but a too large limit (e.g. 10000)
    # may flood the connection and might cause false failure detection to trigger.
    # Test such a configuration by watching all actors at the same time and stop
    # all watched actors at the same time.
    resend-limit = 200

    # WARNING: this setting should not be not changed unless all of its consequences
    # are properly understood which assumes experience with remoting internals
    # or expert advice.
    # This setting defines the time after redelivery attempts of internal management
    # signals are stopped to a remote system that has been not confirmed to be alive by
    # this system before.
    initial-system-message-delivery-timeout = 3 m

    ### Transports and adapters

    # List of the transport drivers that will be loaded by the remoting.
    # A list of fully qualified config paths must be provided where
    # the given configuration path contains a transport-class key
    # pointing to an implementation class of the Transport interface.
    # If multiple transports are provided, the address of the first
    # one will be used as a default address.
    enabled-transports = ["akka.remote.netty.tcp"]

    # Transport drivers can be augmented with adapters by adding their
    # name to the applied-adapters setting in the configuration of a
    # transport. The available adapters should be configured in this
    # section by providing a name, and the fully qualified name of
    # their corresponding implementation. The class given here
    # must implement akka.akka.remote.transport.TransportAdapterProvider
    # and have public constructor without parameters.
    adapters {
      gremlin = "akka.remote.transport.FailureInjectorProvider"
      trttl = "akka.remote.transport.ThrottlerProvider"
    }

    ### Default configuration for the Netty based transport drivers

    netty.tcp {
      # The class given here must implement the akka.remote.transport.Transport
      # interface and offer a public constructor which takes two arguments:
      #  1) akka.actor.ExtendedActorSystem
      #  2) com.typesafe.config.Config
      transport-class = "akka.remote.transport.netty.NettyTransport"

      # Transport drivers can be augmented with adapters by adding their
      # name to the applied-adapters list. The last adapter in the
      # list is the adapter immediately above the driver, while
      # the first one is the top of the stack below the standard
      # Akka protocol
      applied-adapters = []

      transport-protocol = tcp

      # The default remote server port clients should connect to.
      # Default is 2552 (AKKA), use 0 if you want a random available port
      # This port needs to be unique for each actor system on the same machine.
      port = 0

      # The hostname or ip clients should connect to.
      # InetAddress.getLocalHost.getHostAddress is used if empty
      hostname = ""

      # Use this setting to bind a network interface to a different port
      # than remoting protocol expects messages at. This may be used
      # when running akka nodes in a separated networks (under NATs or docker containers).
      # Use 0 if you want a random available port. Examples:
      #
      # akka.remote.netty.tcp.port = 2552
      # akka.remote.netty.tcp.bind-port = 2553
      # Network interface will be bound to the 2553 port, but remoting protocol will
      # expect messages sent to port 2552.
      #
      # akka.remote.netty.tcp.port = 0
      # akka.remote.netty.tcp.bind-port = 0
      # Network interface will be bound to a random port, and remoting protocol will
      # expect messages sent to the bound port.
      #
      # akka.remote.netty.tcp.port = 2552
      # akka.remote.netty.tcp.bind-port = 0
      # Network interface will be bound to a random port, but remoting protocol will
      # expect messages sent to port 2552.
      #
      # akka.remote.netty.tcp.port = 0
      # akka.remote.netty.tcp.bind-port = 2553
      # Network interface will be bound to the 2553 port, and remoting protocol will
      # expect messages sent to the bound port.
      #
      # akka.remote.netty.tcp.port = 2552
      # akka.remote.netty.tcp.bind-port = ""
      # Network interface will be bound to the 2552 port, and remoting protocol will
      # expect messages sent to the bound port.
      #
      # akka.remote.netty.tcp.port if empty
      bind-port = ""

      # Use this setting to bind a network interface to a different hostname or ip
      # than remoting protocol expects messages at.
      # Use "0.0.0.0" to bind to all interfaces.
      # akka.remote.netty.tcp.hostname if empty
      bind-hostname = ""

      # Enables SSL support on this transport
      enable-ssl = false

      # Sets the connectTimeoutMillis of all outbound connections,
      # i.e. how long a connect may take until it is timed out
      connection-timeout = 15 s

      # If set to "<id.of.dispatcher>" then the specified dispatcher
      # will be used to accept inbound connections, and perform IO. If "" then
      # dedicated threads will be used.
      # Please note that the Netty driver only uses this configuration and does
      # not read the "akka.remote.use-dispatcher" entry. Instead it has to be
      # configured manually to point to the same dispatcher if needed.
      use-dispatcher-for-io = ""

      # Sets the high water mark for the in and outbound sockets,
      # set to 0b for platform default
      write-buffer-high-water-mark = 0b

      # Sets the low water mark for the in and outbound sockets,
      # set to 0b for platform default
      write-buffer-low-water-mark = 0b

      # Sets the send buffer size of the Sockets,
      # set to 0b for platform default
      send-buffer-size = 256000b

      # Sets the receive buffer size of the Sockets,
      # set to 0b for platform default
      receive-buffer-size = 256000b

      # Maximum message size the transport will accept, but at least
      # 32000 bytes.
      # Please note that UDP does not support arbitrary large datagrams,
      # so this setting has to be chosen carefully when using UDP.
      # Both send-buffer-size and receive-buffer-size settings has to
      # be adjusted to be able to buffer messages of maximum size.
      maximum-frame-size = 128000b

      # Sets the size of the connection backlog
      backlog = 4096

      # Enables the TCP_NODELAY flag, i.e. disables Nagle’s algorithm
      tcp-nodelay = on

      # Enables TCP Keepalive, subject to the O/S kernel’s configuration
      tcp-keepalive = on

      # Enables SO_REUSEADDR, which determines when an ActorSystem can open
      # the specified listen port (the meaning differs between *nix and Windows)
      # Valid values are "on", "off" and "off-for-windows"
      # due to the following Windows bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4476378
      # "off-for-windows" of course means that it's "on" for all other platforms
      tcp-reuse-addr = off-for-windows

      # Used to configure the number of I/O worker threads on server sockets
      server-socket-worker-pool {
        # Min number of threads to cap factor-based number to
        pool-size-min = 2

        # The pool size factor is used to determine thread pool size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the pool-size-min and
        # pool-size-max values.
        pool-size-factor = 1.0

        # Max number of threads to cap factor-based number to
        pool-size-max = 2
      }

      # Used to configure the number of I/O worker threads on client sockets
      client-socket-worker-pool {
        # Min number of threads to cap factor-based number to
        pool-size-min = 2

        # The pool size factor is used to determine thread pool size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the pool-size-min and
        # pool-size-max values.
        pool-size-factor = 1.0

        # Max number of threads to cap factor-based number to
        pool-size-max = 2
      }


    }

    netty.udp = ${akka.remote.netty.tcp}
    netty.udp {
      transport-protocol = udp
    }

    netty.ssl = ${akka.remote.netty.tcp}
    netty.ssl = {
      # Enable SSL/TLS encryption.
      # This must be enabled on both the client and server to work.
      enable-ssl = true

      security {
        # This is the Java Key Store used by the server connection
        key-store = "keystore"

        # This password is used for decrypting the key store
        key-store-password = "changeme"

        # This password is used for decrypting the key
        key-password = "changeme"

        # This is the Java Key Store used by the client connection
        trust-store = "truststore"

        # This password is used for decrypting the trust store
        trust-store-password = "changeme"

        # Protocol to use for SSL encryption, choose from:
        # Java 6 & 7:
        #   'SSLv3', 'TLSv1'
        # Java 7:
        #   'TLSv1.1', 'TLSv1.2'
        protocol = "TLSv1"

        # Example: ["TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA"]
        # You need to install the JCE Unlimited Strength Jurisdiction Policy
        # Files to use AES 256.
        # More info here:
        # http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider
        enabled-algorithms = ["TLS_RSA_WITH_AES_128_CBC_SHA"]

        # There are three options, in increasing order of security:
        # "" or SecureRandom => (default)
        # "SHA1PRNG" => Can be slow because of blocking issues on Linux
        # "AES128CounterSecureRNG" => fastest startup and based on AES encryption
        # algorithm
        # "AES256CounterSecureRNG"
        #
        # The following are deprecated in Akka 2.4. They use one of 3 possible
        # seed sources, depending on availability: /dev/random, random.org and
        # SecureRandom (provided by Java)
        # "AES128CounterInetRNG"
        # "AES256CounterInetRNG" (Install JCE Unlimited Strength Jurisdiction
        # Policy Files first)
        # Setting a value here may require you to supply the appropriate cipher
        # suite (see enabled-algorithms section above)
        random-number-generator = ""
      }
    }

    ### Default configuration for the failure injector transport adapter

    gremlin {
      # Enable debug logging of the failure injector transport adapter
      debug = off
    }

    ### Default dispatcher for the remoting subsystem

    default-remote-dispatcher {
      type = Dispatcher
      executor = "fork-join-executor"
      fork-join-executor {
        # Min number of threads to cap factor-based parallelism number to
        parallelism-min = 2
        parallelism-max = 2
      }
    }

    backoff-remote-dispatcher {
      type = Dispatcher
      executor = "fork-join-executor"
      fork-join-executor {
        # Min number of threads to cap factor-based parallelism number to
        parallelism-min = 2
        parallelism-max = 2
      }
    }


  }

}
