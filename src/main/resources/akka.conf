#####################################
# Akka Remote Reference Config File #
#####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your akka.conf.

# comments about akka.actor settings left out where they are already in akka-
# actor.jar, because otherwise they would be repeated in config rendering.

channel-dispatcher {
  mailbox-type = "com.vilenet.channels.ChannelMailbox"
  //Other dispatcher configuration goes here
}

channels-dispatcher {
  mailbox-type = "com.vilenet.channels.ChannelsMailbox"
  //Other dispatcher configuration goes here
}

akka {

  loggers = ["akka.event.slf4j.Slf4jLogger"]
  loglevel = "DEBUG"
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

  extensions = [
    "akka.cluster.pubsub.DistributedPubSub"
    "com.romix.akka.serialization.kryo.KryoSerializationExtension$"
  ]

  actor {

    provider = cluster

    debug {
      # enable function of Actor.loggable(), which is to log any received message
      # at DEBUG level, see the “Testing Actor Systems” section of the Akka
      # Documentation at http://akka.io/docs
      receive = off

      # enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill et.c.)
      autoreceive = off

      # enable DEBUG logging of actor lifecycle changes
      lifecycle = off

      # enable DEBUG logging of all LoggingFSMs for events, transitions and timers
      fsm = off

      # enable DEBUG logging of subscription changes on the eventStream
      event-stream = off

      # enable DEBUG logging of unhandled messages
      unhandled = off

      # enable WARN logging of misconfigured routers
      router-misconfiguration = off
    }

    kryo  {
      # Possibles values for type are: graph or nograph
      # graph supports serialization of object graphs with shared nodes
      # and cyclic references, but this comes at the expense of a small
      # overhead nograph does not support object grpahs with shared nodes,
      # but is usually faster
      type = "nograph"

      # Possible values for idstrategy are:
      # default, explicit, incremental
      #
      # default - slowest and produces bigger serialized representation.
      # Contains fully-qualified class names (FQCNs) for each class. Note
      # that selecting this strategy does not work in version 0.3.2, but
      # is available on master and from 0.3.3 onward.
      #
      # explicit - fast and produces compact serialized representation.
      # Requires that all classes that will be serialized are pre-registered
      # using the "mappings" and "classes" sections. To guarantee that both
      # sender and receiver use the same numeric ids for the same classes it
      # is advised to provide exactly the same entries in the "mappings"
      # section.
      #
      # incremental - fast and produces compact serialized representation.
      # Support optional pre-registering of classes using the "mappings"
      # and "classes" sections. If class is not pre-registered, it will be
      # registered dynamically by picking a next available id To guarantee
      # that both sender and receiver use the same numeric ids for the same
      # classes it is advised to pre-register them using at least the "classes" section.
      idstrategy = "default"

      # Define a default size for serializer pool
      # Try to define the size to be at least as big as the max possible
      # number of threads that may be used for serialization, i.e. max
      # number of threads allowed for the scheduler
      serializer-pool-size = 16

      # Define a default size for byte buffers used during serialization
      buffer-size = 4096

      # The serialization byte buffers are doubled as needed until they
      # exceed max-buffer-size and an exception is thrown. Can be -1
      # for no maximum.
      max-buffer-size = -1

      # If set, akka uses manifests to put a class name
      # of the top-level object into each message
      use-manifests = false

      # If set it will use the UnsafeInput and UnsafeOutput
      # Kyro IO instances. Please note that there is no guarantee
      # for backward/forward compatibility of unsafe serialization.
      # It is also not compatible with the safe-serialized values.
      # The unsafe IO usually creates bugger payloads but is faster
      # for some types, e.g. native arrays.
      use-unsafe = true

      # The transformations that have be done while serialization
      # Supported transformations: compression and encryption
      # accepted values(comma separated if multiple): off | lz4 | deflate | aes
      # Transformations occur in the order they are specified
      post-serialization-transformations = "off"

      # Settings for aes encryption, if included in transformations AES
      # algo mode, key and custom key class can be specified AES algo mode
      # defaults to 'AES/CBC/PKCS5Padding' and key to 'ThisIsASecretKey'.
      # If custom key class is provided, Kryo will use the class specified
      # by a fully qualified class name to get custom AES key. Such a
      # class should define the method 'kryoAESKey'. This key overrides 'key'.
      # If class doesn't contain 'kryoAESKey' method, specified key is used.
      # If this is not present, default key is used
      #encryption {
      #  aes {
      #    mode = "AES/CBC/PKCS5Padding"
      #    key = j68KkRjq21ykRGAQ
      #    custom-key-class = "CustomAESKeyClass"
      #  }
      #}

      # Log implicitly registered classes. Useful, if you want to know all
      # classes which are serialized. You can then use this information in
      # the mappings and/or classes sections
      implicit-registration-logging = false

      # If enabled, Kryo logs a lot of information about serialization process.
      # Useful for debugging and lowl-level tweaking
      kryo-trace = false

      # If proviced, Kryo uses the class specified by a fully qualified
      # class name to perform a custom initialization of Kryo instances in
      # addition to what is done automatically based on the config file.
      #kryo-custom-serializer-init = "CustomKryoSerializerInitFQCN"

      # If enabled, allows Kryo to resolve subclasses of registered Types.
      #
      # This is primarily useful when idstrategy is set to "explicit". In this
      # case, all classes to be serialized must be explicitly registered. The
      # problem is that a large number of common Scala and Akka types (such as
      # Map and ActorRef) are actually traits that mask a large number of
      # specialized classes that deal with various situations and optimizations.
      # It isn't straightforward to register all of these, so you can instead
      # register a single supertype, with a serializer that can handle *all* of
      # the subclasses, and the subclasses get serialized with that.
      #
      # Use this with care: you should only rely on this when you are confident
      # that the superclass serializer covers all of the special cases properly.
      resolve-subclasses = false

      # Define mappings from a fully qualified class name to a numeric id.
      # Smaller ids lead to smaller sizes of serialized representations.
      #
      # This section is mandatory for idstartegy=explicit
      # This section is optional  for idstartegy=incremental
      # This section is ignored   for idstartegy=default
      #
      # The smallest possible id should start at 20 (or even higher), because
      # ids below it are used by Kryo internally e.g. for built-in Java and
      # Scala types
      mappings {
        "com.vilenet.coders.commands.ChannelCommand" = 29
        "com.vilenet.coders.commands.UserCommand" = 30
        "com.vilenet.coders.commands.UserToChannelCommand" = 31
        "com.vilenet.coders.commands.OperableCommand" = 32
        "com.vilenet.coders.commands.ReturnableCommand" = 33
        "com.vilenet.coders.commands.ChannelsCommand" = 34
        "com.vilenet.coders.commands.TopCommand" = 35
        "com.vilenet.coders.commands.WhoisCommand" = 36
        "com.vilenet.coders.commands.AwayCommand" = 37
        "com.vilenet.coders.commands.DndCommand" = 38
        "com.vilenet.coders.commands.WhoCommand" = 39
        "com.vilenet.coders.commands.WhoCommandToChannel" = 40
        "com.vilenet.servers.SendBirth$" = 41
        "com.vilenet.servers.ServerOnline$" = 62

        "com.vilenet.servers.SplitMe$" = 47

        "com.vilenet.users.Add" = 48
        "com.vilenet.users.Rem" = 49
        "com.vilenet.users.WhisperTo" = 50
        "com.vilenet.users.GetUsers$" = 51
        "com.vilenet.users.ReceivedUser" = 52
        "com.vilenet.users.ReceivedUsers" = 53
        "com.vilenet.users.UserToChannelCommandAck" = 54
        "com.vilenet.users.UsersUserAdded" = 55
        "com.vilenet.users.UserUpdated" = 42

        "com.vilenet.channels.GetChannels$" = 56
        "com.vilenet.channels.ChannelCreated" = 57
        "com.vilenet.channels.GetChannelUsers" = 58
        "com.vilenet.channels.ReceivedChannel" = 59
        "com.vilenet.channels.UserAdded" = 60

        "akka.actor.Identify" = 84
        "akka.actor.ActorIdentity" = 85

        "com.vilenet.servers.RemoteEvent" = 61
        "akka.remote.DaemonMsgCreate" = 64
        "akka.dispatch.sysmsg.SystemMessage" = 65
        "akka.remote.RemoteWatcher" = 66
        "akka.actor.ActorRef" = 67
        "akka.actor.LocalActorRef" = 68
        "akka.remote.RemoteActorRef" = 69
        "com.vilenet.utils.RealKeyedCaseInsensitiveHashMap" = 70
        "com.vilenet.users.BinaryProtocol" = 71
        "com.vilenet.users.TelnetProtocol" = 72
        "com.vilenet.channels.User" = 73
        "com.vilenet.channels.ChannelUsersLoad" = 74

        "scala.collection.mutable.LinkedHashMap" = 75
        "com.vilenet.channels.utils.LocalUsersSet" = 76
        "com.vilenet.channels.AddUser" = 77
        "com.vilenet.channels.RemUser" = 78
        "com.vilenet.coders.commands.ChatCommand" = 79
        "com.vilenet.coders.commands.EmoteCommand" = 80
        "com.vilenet.channels.ChannelsAre" = 86
        "scala.Tuple2" = 90
        "scala.None$" = 91
        "scala.Some" = 92
        "akka.actor.RepointableActorRef" = 93
        "scala.collection.mutable.ArrayBuffer" = 94
        "com.vilenet.coders.commands.BroadcastCommand" = 95
        "com.vilenet.users.RemActors" = 96
        "com.vilenet.channels.RemAll" = 97
      }

      kryo-reference-map = false

      # Define a set of fully qualified class names for
      # classes to be used for serialization.
      # The ids for those classes will be assigned automatically,
      # but respecting the order of declaration in this section
      #
      # This section is optional  for idstartegy=incremental
      # This section is ignored   for idstartegy=default
      # This section is optional  for idstartegy=explicit
      classes = [
        "akka.actor.ActorRef"
        "akka.actor.LocalActorRef"
        "akka.remote.RemoteActorRef"
        "com.vilenet.utils.RealKeyedCaseInsensitiveHashMap"
        "com.vilenet.users.BinaryProtocol$"
        "com.vilenet.users.TelnetProtocol$"
        "com.vilenet.channels.User"
        "com.vilenet.channels.ChannelUsersLoad"
        "scala.collection.mutable.LinkedHashMap"
        "com.vilenet.channels.utils.LocalUsersSet"

        "com.vilenet.coders.commands.ChatCommand"
        "com.vilenet.coders.commands.EmoteCommand"
        "com.vilenet.coders.commands.ChannelCommand"
        "com.vilenet.coders.commands.UserCommand"
        "com.vilenet.coders.commands.UserToChannelCommand"
        "com.vilenet.coders.commands.OperableCommand"
        "com.vilenet.coders.commands.ReturnableCommand"
        "com.vilenet.coders.commands.ChannelsCommand"
        "com.vilenet.coders.commands.TopCommand"
        "com.vilenet.coders.commands.WhoisCommand"
        "com.vilenet.coders.commands.AwayCommand"
        "com.vilenet.coders.commands.DndCommand"
        "com.vilenet.coders.commands.WhoCommand"
        "com.vilenet.coders.commands.WhoCommandToChannel"

        "com.vilenet.servers.SendBirth$"
        "com.vilenet.servers.ServerOnline$"
        "com.vilenet.servers.SplitMe$"

        "com.vilenet.users.Add"
        "com.vilenet.users.Rem"
        "com.vilenet.users.WhisperTo"
        "com.vilenet.users.GetUsers"
        "com.vilenet.users.GetUsers$"
        "com.vilenet.users.ReceivedUser"
        "com.vilenet.users.ReceivedUsers"
        "com.vilenet.users.UserToChannelCommandAck"
        "com.vilenet.users.UsersUserAdded"
        "com.vilenet.users.UserUpdated"

        "com.vilenet.channels.AddUser"
        "com.vilenet.channels.RemUser"
        "com.vilenet.channels.GetChannels$"
        "com.vilenet.channels.ChannelCreated"
        "com.vilenet.channels.GetChannelUsers"
        "com.vilenet.channels.ReceivedChannel"
        "com.vilenet.channels.UserAdded"
        "com.vilenet.channels.ChannelsAre"

        "akka.actor.Identify"
        "akka.actor.ActorIdentity"

        "com.vilenet.servers.RemoteEvent"
        "scala.Tuple2"
        "scala.None$"
        "scala.Some"
        "akka.actor.RepointableActorRef"
        "com.vilenet.coders.commands.BroadcastCommand"
        "com.vilenet.users.RemActors"
        "com.vilenet.channels.RemAll"
      ]
    }

    serializers {
      akka-containers = "akka.remote.serialization.MessageContainerSerializer"
      akka-misc = "akka.remote.serialization.MiscMessageSerializer"
      akka-cluster = "akka.cluster.protobuf.ClusterMessageSerializer"
      akka-pubsub = "akka.cluster.pubsub.protobuf.DistributedPubSubMessageSerializer"
      akka-system-msg = "akka.remote.serialization.SystemMessageSerializer"
      artery = "akka.remote.serialization.ArteryMessageSerializer"
      proto = "akka.remote.serialization.ProtobufSerializer"
      daemon-create = "akka.remote.serialization.DaemonMsgCreateSerializer"
      primitive-bytestring = "akka.remote.serialization.ByteStringSerializer"
      primitive-int = "akka.remote.serialization.IntSerializer"
      primitive-long = "akka.remote.serialization.LongSerializer"
      primitive-string = "akka.remote.serialization.StringSerializer"

      kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
    }

    serialization-bindings {
      "java.io.Serializable" = none

      "akka.actor.ActorSelectionMessage" = akka-containers
      "akka.remote.DaemonMsgCreate" = daemon-create
      "akka.cluster.ClusterMessage" = akka-cluster
      "akka.cluster.pubsub.DistributedPubSubMessage" = akka-pubsub
      "akka.remote.artery.ArteryMessage" = artery

      "akka.actor.Identify" = akka-misc
      "akka.actor.ActorIdentity" = akka-misc
      "scala.Some" = akka-misc
      "scala.None$" = akka-misc
      "akka.actor.Status$Success" = akka-misc
      "akka.actor.Status$Failure" = akka-misc
      "akka.actor.ActorRef" = akka-misc
      "akka.actor.PoisonPill$" = akka-misc
      "akka.actor.Kill$" = akka-misc
      "akka.remote.RemoteWatcher$Heartbeat$" = akka-misc
      "akka.remote.RemoteWatcher$HeartbeatRsp" = akka-misc
      "akka.actor.ActorInitializationException" = akka-misc

      "akka.dispatch.sysmsg.SystemMessage" = akka-system-msg

      "java.lang.String" = primitive-string
      "akka.util.ByteString$ByteString1C" = primitive-bytestring
      "akka.util.ByteString$ByteString1" = primitive-bytestring
      "akka.util.ByteString$ByteStrings" = primitive-bytestring
      "java.lang.Long" = primitive-long
      "scala.Long" = primitive-long
      "java.lang.Integer" = primitive-int
      "scala.Int" = primitive-int

      # Java Serializer is by default used for exceptions.
      # It's recommended that you implement custom serializer for exceptions that are
      # sent remotely, e.g. in akka.actor.Status.Failure for ask replies. You can add
      # binding to akka-misc (MiscMessageSerializerSpec) for the exceptions that have
      # a constructor with single message String or constructor with message String as
      # first parameter and cause Throwable as second parameter. Note that it's not
      # safe to add this binding for general exceptions such as IllegalArgumentException
      # because it may have a subclass without required constructor.
      "java.lang.Throwable" = java
      "akka.actor.IllegalActorStateException" = akka-misc
      "akka.actor.ActorKilledException" = akka-misc
      "akka.actor.InvalidActorNameException" = akka-misc
      "akka.actor.InvalidMessageException" = akka-misc


      "com.vilenet.coders.commands.Command" = kryo
      "com.vilenet.utils.RealKeyedCaseInsensitiveHashMap" = kryo
      "akka.actor.ActorRef" = kryo
      "akka.actor.Identify" = kryo
      "akka.actor.ActorIdentity" = kryo
      "scala.Tuple2" = kryo

      # Since akka.protobuf.Message does not extend Serializable but
      # GeneratedMessage does, need to use the more specific one here in order
      # to avoid ambiguity.
      "akka.protobuf.GeneratedMessage" = proto

      # Since com.google.protobuf.Message does not extend Serializable but
      # GeneratedMessage does, need to use the more specific one here in order
      # to avoid ambiguity.
      # This com.google.protobuf serialization binding is only used if the class can be loaded,
      # i.e. com.google.protobuf dependency has been added in the application project.
      "com.google.protobuf.GeneratedMessage" = proto
    }

    serialization-identifiers {
      "akka.remote.serialization.ProtobufSerializer" = 2
      "akka.remote.serialization.DaemonMsgCreateSerializer" = 3
      "akka.cluster.protobuf.ClusterMessageSerializer" = 5
      "akka.remote.serialization.MessageContainerSerializer" = 6
      "akka.cluster.pubsub.protobuf.DistributedPubSubMessageSerializer" = 9
      "akka.remote.serialization.MiscMessageSerializer" = 16
      "akka.remote.serialization.ArteryMessageSerializer" = 17
      "akka.remote.serialization.LongSerializer" = 18
      "akka.remote.serialization.IntSerializer" = 19
      "akka.remote.serialization.StringSerializer" = 20
      "akka.remote.serialization.ByteStringSerializer" = 21
      "akka.remote.serialization.SystemMessageSerializer" = 22

      "com.romix.akka.serialization.kryo.KryoSerializer" = 23
    }

    deployment {

      default {

        # if this is set to a valid remote address, the named actor will be
        # deployed at that node e.g. "akka.tcp://sys@host:port"
        remote = ""

        cluster {
          # enable cluster aware router that deploys to nodes in the cluster
          enabled = off

          # Maximum number of routees that will be deployed on each cluster
          # member node.
          # Note that max-total-nr-of-instances defines total number of routees, but
          # number of routees per node will not be exceeded, i.e. if you
          # define max-total-nr-of-instances = 50 and max-nr-of-instances-per-node = 2
          # it will deploy 2 routees per new member in the cluster, up to
          # 25 members.
          max-nr-of-instances-per-node = 1

          # Maximum number of routees that will be deployed, in total
          # on all nodes. See also description of max-nr-of-instances-per-node.
          # For backwards compatibility reasons, nr-of-instances
          # has the same purpose as max-total-nr-of-instances for cluster
          # aware routers and nr-of-instances (if defined by user) takes
          # precedence over max-total-nr-of-instances.
          max-total-nr-of-instances = 10000

          # Defines if routees are allowed to be located on the same node as
          # the head router actor, or only on remote nodes.
          # Useful for master-worker scenario where all routees are remote.
          allow-local-routees = on

          # Use members with specified role, or all members if undefined or empty.
          use-role = ""

        }

        target {

          # A list of hostnames and ports for instantiating the children of a
          # router
          #   The format should be on "akka.tcp://sys@host:port", where:
          #    - sys is the remote actor system name
          #    - hostname can be either hostname or IP address the remote actor
          #      should connect to
          #    - port should be the port for the remote server on the other node
          # The number of actor instances to be spawned is still taken from the
          # nr-of-instances setting as for local routers; the instances will be
          # distributed round-robin among the given nodes.
          nodes = []

        }
      }
    }
  }

  cluster {

    debug {
      # log heartbeat events (very verbose, useful mostly when debugging heartbeating issues)
      verbose-heartbeat-logging = off
    }

    # Initial contact points of the cluster.
    # The nodes to join automatically at startup.
    # Comma separated full URIs defined by a string on the form of
    # "akka.tcp://system@hostname:port"
    # Leave as empty if the node is supposed to be joined manually.
    ### SPECIFIED IN start.sh script
    # seed-nodes = []

    # how long to wait for one of the seed nodes to reply to initial join request
    seed-node-timeout = 2s

    # If a join request fails it will be retried after this period.
    # Disable join retry by specifying "off".
    retry-unsuccessful-join-after = 2s

    # Should the 'leader' in the cluster be allowed to automatically mark
    # unreachable nodes as DOWN after a configured time of unreachability?
    # Using auto-down implies that two separate clusters will automatically be
    # formed in case of network partition.
    # Disable with "off" or specify a duration to enable auto-down.

    # THIS MUST BE NOT SET TO OFF FOR wServ
    # OTHERWISE REJOINING SERVERS WILL TRY TO REUSE
    # OLD ACTORS WHICH ARE NO LONGER REACHABLE
    # - Filip
    auto-down-unreachable-after = 10s

    # Time margin after which shards or singletons that belonged to a downed/removed
    # partition are created in surviving partition. The purpose of this margin is that
    # in case of a network partition the persistent actors in the non-surviving partitions
    # must be stopped before corresponding persistent actors are started somewhere else.
    # This is useful if you implement downing strategies that handle network partitions,
    # e.g. by keeping the larger side of the partition and shutting down the smaller side.
    # It will not add any extra safety for auto-down-unreachable-after, since that is not
    # handling network partitions.
    # Disable with "off" or specify a duration to enable.
    down-removal-margin = off

    # Pluggable support for downing of nodes in the cluster.
    # If this setting is left empty behaviour will depend on 'auto-down-unreachable' in the following ways:
    # * if it is 'off' the `NoDowning` provider is used and no automatic downing will be performed
    # * if it is set to a duration the `AutoDowning` provider is with the configured downing duration
    #
    # If specified the value must be the fully qualified class name of a subclass of
    # `akka.cluster.DowningProvider` having a public one argument constructor accepting an `ActorSystem`
    downing-provider-class = ""

    # Artery only setting
    # When a node has been gracefully removed, let this time pass (to allow for example
    # cluster singleton handover to complete) and then quarantine the removed node.
    quarantine-removed-node-after=10s

    # By default, the leader will not move 'Joining' members to 'Up' during a network
    # split. This feature allows the leader to accept 'Joining' members to be 'WeaklyUp'
    # so they become part of the cluster even during a network split. The leader will
    # move 'WeaklyUp' members to 'Up' status once convergence has been reached. This
    # feature must be off if some members are running Akka 2.3.X.
    # WeaklyUp is an EXPERIMENTAL feature.
    allow-weakly-up-members = off

    # The roles of this member. List of strings, e.g. roles = ["A", "B"].
    # The roles are part of the membership information and can be used by
    # routers or other services to distribute work to certain member types,
    # e.g. front-end and back-end nodes.
    roles = []

    role {
      # Minimum required number of members of a certain role before the leader
      # changes member status of 'Joining' members to 'Up'. Typically used together
      # with 'Cluster.registerOnMemberUp' to defer some action, such as starting
      # actors, until the cluster has reached a certain size.
      # E.g. to require 2 nodes with role 'frontend' and 3 nodes with role 'backend':
      #   frontend.min-nr-of-members = 2
      #   backend.min-nr-of-members = 3
      #<role-name>.min-nr-of-members = 1
    }

    # Minimum required number of members before the leader changes member status
    # of 'Joining' members to 'Up'. Typically used together with
    # 'Cluster.registerOnMemberUp' to defer some action, such as starting actors,
    # until the cluster has reached a certain size.
    min-nr-of-members = 1

    # Enable/disable info level logging of cluster events
    log-info = on

    # Enable or disable JMX MBeans for management of the cluster
    jmx.enabled = off

    # how long should the node wait before starting the periodic tasks
    # maintenance tasks?
    periodic-tasks-initial-delay = 1s

    # how often should the node send out gossip information?
    gossip-interval = 1s

    # discard incoming gossip messages if not handled within this duration
    gossip-time-to-live = 2s

    # how often should the leader perform maintenance tasks?
    leader-actions-interval = 1s

    # how often should the node move nodes, marked as unreachable by the failure
    # detector, out of the membership ring?
    unreachable-nodes-reaper-interval = 1s

    # How often the current internal stats should be published.
    # A value of 0s can be used to always publish the stats, when it happens.
    # Disable with "off".
    publish-stats-interval = off

    # The id of the dispatcher to use for cluster actors. If not specified
    # default dispatcher is used.
    # If specified you need to define the settings of the actual dispatcher.
    use-dispatcher = ""

    # Gossip to random node with newer or older state information, if any with
    # this probability. Otherwise Gossip to any random live node.
    # Probability value is between 0.0 and 1.0. 0.0 means never, 1.0 means always.
    gossip-different-view-probability = 0.8

    # Reduced the above probability when the number of nodes in the cluster
    # greater than this value.
    reduce-gossip-different-view-probability = 400

    # Settings for the Phi accrual failure detector (http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf
    # [Hayashibara et al]) used by the cluster subsystem to detect unreachable
    # members.
    # The default PhiAccrualFailureDetector will trigger if there are no heartbeats within
    # the duration heartbeat-interval + acceptable-heartbeat-pause + threshold_adjustment,
    # i.e. around 5.5 seconds with default settings.
    failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = "akka.remote.PhiAccrualFailureDetector"

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 1 s

      # Defines the failure detector threshold.
      # A low threshold is prone to generate many wrong suspicions but ensures
      # a quick detection in the event of a real crash. Conversely, a high
      # threshold generates fewer mistakes but needs more time to detect
      # actual crashes.
      threshold = 8.0

      # Number of the samples of inter-heartbeat arrival times to adaptively
      # calculate the failure timeout for connections.
      max-sample-size = 1000

      # Minimum standard deviation to use for the normal distribution in
      # AccrualFailureDetector. Too low standard deviation might result in
      # too much sensitivity for sudden, but normal, deviations in heartbeat
      # inter arrival times.
      min-std-deviation = 100 ms

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # This margin is important to be able to survive sudden, occasional,
      # pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 3 s

      # Number of member nodes that each member will send heartbeat messages to,
      # i.e. each node will be monitored by this number of other nodes.
      monitored-by-nr-of-members = 5

      # After the heartbeat request has been sent the first failure detection
      # will start after this period, even though no heartbeat message has
      # been received.
      expected-response-after = 1 s

    }

    metrics {
      # Enable or disable metrics collector for load-balancing nodes.
      enabled = off

      # FQCN of the metrics collector implementation.
      # It must implement akka.cluster.MetricsCollector and
      # have public constructor with akka.actor.ActorSystem parameter.
      # The default SigarMetricsCollector uses JMX and Hyperic SIGAR, if SIGAR
      # is on the classpath, otherwise only JMX.
      collector-class = "akka.cluster.SigarMetricsCollector"

      # How often metrics are sampled on a node.
      # Shorter interval will collect the metrics more often.
      collect-interval = 3s

      # How often a node publishes metrics information.
      gossip-interval = 3s

      # How quickly the exponential weighting of past data is decayed compared to
      # new data. Set lower to increase the bias toward newer values.
      # The relevance of each data sample is halved for every passing half-life
      # duration, i.e. after 4 times the half-life, a data sample’s relevance is
      # reduced to 6% of its original relevance. The initial relevance of a data
      # sample is given by 1 – 0.5 ^ (collect-interval / half-life).
      # See http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
      moving-average-half-life = 12s
    }

    # If the tick-duration of the default scheduler is longer than the
    # tick-duration configured here a dedicated scheduler will be used for
    # periodic tasks of the cluster, otherwise the default scheduler is used.
    # See akka.scheduler settings for more details.
    scheduler {
      tick-duration = 33ms
      ticks-per-wheel = 512
    }

    pub-sub {
      # Actor name of the mediator actor, /system/distributedPubSubMediator
      name = distributedPubSubMediator

      # Start the mediator on members tagged with this role.
      # All members are used if undefined or empty.
      role = ""

      # The routing logic to use for 'Send'
      # Possible values: random, round-robin, broadcast
      routing-logic = random

      # How often the DistributedPubSubMediator should send out gossip information
      gossip-interval = 1s

      # Removed entries are pruned after this duration
      removed-time-to-live = 120s

      # Maximum number of elements to transfer in one message when synchronizing the registries.
      # Next chunk will be transferred in next round of gossip.
      max-delta-elements = 3000

      # The id of the dispatcher to use for DistributedPubSubMediator actors.
      # If not specified default dispatcher is used.
      # If specified you need to define the settings of the actual dispatcher.
      use-dispatcher = ""

    }
  }

    remote {
      ### Settings shared by classic remoting and Artery (the new implementation of remoting)

      # If set to a nonempty string remoting will use the given dispatcher for
      # its internal actors otherwise the default dispatcher is used. Please note
      # that since remoting can load arbitrary 3rd party drivers (see
      # "enabled-transport" and "adapters" entries) it is not guaranteed that
      # every module will respect this setting.
      use-dispatcher = "akka.remote.default-remote-dispatcher"

      # Settings for the failure detector to monitor connections.
      # For TCP it is not important to have fast failure detection, since
      # most connection failures are captured by TCP itself.
      # The default DeadlineFailureDetector will trigger if there are no heartbeats within
      # the duration heartbeat-interval + acceptable-heartbeat-pause, i.e. 20 seconds
      # with the default settings.
      transport-failure-detector {

        # FQCN of the failure detector implementation.
        # It must implement akka.remote.FailureDetector and have
        # a public constructor with a com.typesafe.config.Config and
        # akka.actor.EventStream parameter.
        implementation-class = "akka.remote.DeadlineFailureDetector"

        # How often keep-alive heartbeat messages should be sent to each connection.
        heartbeat-interval = 4 s

        # Number of potentially lost/delayed heartbeats that will be
        # accepted before considering it to be an anomaly.
        # A margin to the `heartbeat-interval` is important to be able to survive sudden,
        # occasional, pauses in heartbeat arrivals, due to for example garbage collect or
        # network drop.
        acceptable-heartbeat-pause = 16 s
      }

      # Settings for the Phi accrual failure detector (http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf
      # [Hayashibara et al]) used for remote death watch.
      # The default PhiAccrualFailureDetector will trigger if there are no heartbeats within
      # the duration heartbeat-interval + acceptable-heartbeat-pause + threshold_adjustment,
      # i.e. around 12.5 seconds with default settings.
      watch-failure-detector {

        # FQCN of the failure detector implementation.
        # It must implement akka.remote.FailureDetector and have
        # a public constructor with a com.typesafe.config.Config and
        # akka.actor.EventStream parameter.
        implementation-class = "akka.remote.PhiAccrualFailureDetector"

        # How often keep-alive heartbeat messages should be sent to each connection.
        heartbeat-interval = 1 s

        # Defines the failure detector threshold.
        # A low threshold is prone to generate many wrong suspicions but ensures
        # a quick detection in the event of a real crash. Conversely, a high
        # threshold generates fewer mistakes but needs more time to detect
        # actual crashes.
        threshold = 10.0

        # Number of the samples of inter-heartbeat arrival times to adaptively
        # calculate the failure timeout for connections.
        max-sample-size = 200

        # Minimum standard deviation to use for the normal distribution in
        # AccrualFailureDetector. Too low standard deviation might result in
        # too much sensitivity for sudden, but normal, deviations in heartbeat
        # inter arrival times.
        min-std-deviation = 100 ms

        # Number of potentially lost/delayed heartbeats that will be
        # accepted before considering it to be an anomaly.
        # This margin is important to be able to survive sudden, occasional,
        # pauses in heartbeat arrivals, due to for example garbage collect or
        # network drop.
        acceptable-heartbeat-pause = 10 s


        # How often to check for nodes marked as unreachable by the failure
        # detector
        unreachable-nodes-reaper-interval = 1s

        # After the heartbeat request has been sent the first failure detection
        # will start after this period, even though no heartbeat mesage has
        # been received.
        expected-response-after = 1 s

      }

      # remote deployment configuration section
      deployment {
        # If true, will only allow specific classes to be instanciated on this system via remote deployment
        enable-whitelist = off

        whitelist = []
      }
      #//#shared

      #//#classic

      ### Configuration for classic remoting

      # Timeout after which the startup of the remoting subsystem is considered
      # to be failed. Increase this value if your transport drivers (see the
      # enabled-transports section) need longer time to be loaded.
      startup-timeout = 10s

      # Timout after which the graceful shutdown of the remoting subsystem is
      # considered to be failed. After the timeout the remoting system is
      # forcefully shut down. Increase this value if your transport drivers
      # (see the enabled-transports section) need longer time to stop properly.
      shutdown-timeout = 5s

      # Before shutting down the drivers, the remoting subsystem attempts to flush
      # all pending writes. This setting controls the maximum time the remoting is
      # willing to wait before moving on to shut down the drivers.
      flush-wait-on-shutdown = 2s

      # Reuse inbound connections for outbound messages
      use-passive-connections = on

      # Controls the backoff interval after a refused write is reattempted.
      # (Transports may refuse writes if their internal buffer is full)
      backoff-interval = 5ms

      # Acknowledgment timeout of management commands sent to the transport stack.
      command-ack-timeout = 30s

      # The timeout for outbound associations to perform the handshake.
      # If the transport is akka.remote.netty.tcp or akka.remote.netty.ssl
      # the configured connection-timeout for the transport will be used instead.
      handshake-timeout = 15s

      ### Security settings

      # Enable untrusted mode for full security of server managed actors, prevents
      # system messages to be send by clients, e.g. messages like 'Create',
      # 'Suspend', 'Resume', 'Terminate', 'Supervise', 'Link' etc.
      untrusted-mode = off

      # When 'untrusted-mode=on' inbound actor selections are by default discarded.
      # Actors with paths defined in this white list are granted permission to receive actor
      # selections messages.
      # E.g. trusted-selection-paths = ["/user/receptionist", "/user/namingService"]
      trusted-selection-paths = []

      # Should the remote server require that its peers share the same
      # secure-cookie (defined in the 'remote' section)? Secure cookies are passed
      # between during the initial handshake. Connections are refused if the initial
      # message contains a mismatching cookie or the cookie is missing.
      require-cookie = off

      # Deprecated since 2.4-M1
      secure-cookie = ""

      ### Logging

      # If this is "on", Akka will log all inbound messages at DEBUG level,
      # if off then they are not logged
      log-received-messages = off

      # If this is "on", Akka will log all outbound messages at DEBUG level,
      # if off then they are not logged
      log-sent-messages = off

      # Sets the log granularity level at which Akka logs remoting events. This setting
      # can take the values OFF, ERROR, WARNING, INFO, DEBUG, or ON. For compatibility
      # reasons the setting "on" will default to "debug" level. Please note that the effective
      # logging level is still determined by the global logging level of the actor system:
      # for example debug level remoting events will be only logged if the system
      # is running with debug level logging.
      # Failures to deserialize received messages also fall under this flag.
      log-remote-lifecycle-events = on

      # Logging of message types with payload size in bytes larger than
      # this value. Maximum detected size per message type is logged once,
      # with an increase threshold of 10%.
      # By default this feature is turned off. Activate it by setting the property to
      # a value in bytes, such as 1000b. Note that for all messages larger than this
      # limit there will be extra performance and scalability cost.
      log-frame-size-exceeding = off

      # Log warning if the number of messages in the backoff buffer in the endpoint
      # writer exceeds this limit. It can be disabled by setting the value to off.
      log-buffer-size-exceeding = 50000



      # After failed to establish an outbound connection, the remoting will mark the
      # address as failed. This configuration option controls how much time should
      # be elapsed before reattempting a new connection. While the address is
      # gated, all messages sent to the address are delivered to dead-letters.
      # Since this setting limits the rate of reconnects setting it to a
      # very short interval (i.e. less than a second) may result in a storm of
      # reconnect attempts.
      retry-gate-closed-for = 5 s

      # After catastrophic communication failures that result in the loss of system
      # messages or after the remote DeathWatch triggers the remote system gets
      # quarantined to prevent inconsistent behavior.
      # This setting controls how long the Quarantine marker will be kept around
      # before being removed to avoid long-term memory leaks.
      # WARNING: DO NOT change this to a small value to re-enable communication with
      # quarantined nodes. Such feature is not supported and any behavior between
      # the affected systems after lifting the quarantine is undefined.
      prune-quarantine-marker-after = 5 d

      # If system messages have been exchanged between two systems (i.e. remote death
      # watch or remote deployment has been used) a remote system will be marked as
      # quarantined after the two system has no active association, and no
      # communication happens during the time configured here.
      # The only purpose of this setting is to avoid storing system message redelivery
      # data (sequence number state, etc.) for an undefined amount of time leading to long
      # term memory leak. Instead, if a system has been gone for this period,
      # or more exactly
      # - there is no association between the two systems (TCP connection, if TCP transport is used)
      # - neither side has been attempting to communicate with the other
      # - there are no pending system messages to deliver
      # for the amount of time configured here, the remote system will be quarantined and all state
      # associated with it will be dropped.
      quarantine-after-silence = 5 d

      # This setting defines the maximum number of unacknowledged system messages
      # allowed for a remote system. If this limit is reached the remote system is
      # declared to be dead and its UID marked as tainted.
      system-message-buffer-size = 20000

      # This setting defines the maximum idle time after an individual
      # acknowledgement for system messages is sent. System message delivery
      # is guaranteed by explicit acknowledgement messages. These acks are
      # piggybacked on ordinary traffic messages. If no traffic is detected
      # during the time period configured here, the remoting will send out
      # an individual ack.
      system-message-ack-piggyback-timeout = 0.3 s

      # This setting defines the time after internal management signals
      # between actors (used for DeathWatch and supervision) that have not been
      # explicitly acknowledged or negatively acknowledged are resent.
      # Messages that were negatively acknowledged are always immediately
      # resent.
      resend-interval = 2s

      # Maximum number of unacknowledged system messages that will be resent
      # each 'resend-interval'. If you watch many (> 1000) remote actors you can
      # increase this value to for example 600, but a too large limit (e.g. 10000)
      # may flood the connection and might cause false failure detection to trigger.
      # Test such a configuration by watching all actors at the same time and stop
      # all watched actors at the same time.
      resend-limit = 200

      # WARNING: this setting should not be not changed unless all of its consequences
      # are properly understood which assumes experience with remoting internals
      # or expert advice.
      # This setting defines the time after redelivery attempts of internal management
      # signals are stopped to a remote system that has been not confirmed to be alive by
      # this system before.
      initial-system-message-delivery-timeout = 3 m

      ### Transports and adapters

      # List of the transport drivers that will be loaded by the remoting.
      # A list of fully qualified config paths must be provided where
      # the given configuration path contains a transport-class key
      # pointing to an implementation class of the Transport interface.
      # If multiple transports are provided, the address of the first
      # one will be used as a default address.
      enabled-transports = []

      # Transport drivers can be augmented with adapters by adding their
      # name to the applied-adapters setting in the configuration of a
      # transport. The available adapters should be configured in this
      # section by providing a name, and the fully qualified name of
      # their corresponding implementation. The class given here
      # must implement akka.akka.remote.transport.TransportAdapterProvider
      # and have public constructor without parameters.
      adapters {
        gremlin = "akka.remote.transport.FailureInjectorProvider"
        trttl = "akka.remote.transport.ThrottlerProvider"
      }

      ### Default configuration for the Netty based transport drivers

      netty.tcp {
        # The class given here must implement the akka.remote.transport.Transport
        # interface and offer a public constructor which takes two arguments:
        #  1) akka.actor.ExtendedActorSystem
        #  2) com.typesafe.config.Config
        transport-class = "akka.remote.transport.netty.NettyTransport"

        # Transport drivers can be augmented with adapters by adding their
        # name to the applied-adapters list. The last adapter in the
        # list is the adapter immediately above the driver, while
        # the first one is the top of the stack below the standard
        # Akka protocol
        applied-adapters = []

        transport-protocol = tcp

        # The default remote server port clients should connect to.
        # Default is 2552 (AKKA), use 0 if you want a random available port
        # This port needs to be unique for each actor system on the same machine.
        port = 2552

        # The hostname or ip clients should connect to.
        # InetAddress.getLocalHost.getHostAddress is used if empty
        hostname = ""

        # Use this setting to bind a network interface to a different port
        # than remoting protocol expects messages at. This may be used
        # when running akka nodes in a separated networks (under NATs or docker containers).
        # Use 0 if you want a random available port. Examples:
        #
        # akka.remote.netty.tcp.port = 2552
        # akka.remote.netty.tcp.bind-port = 2553
        # Network interface will be bound to the 2553 port, but remoting protocol will
        # expect messages sent to port 2552.
        #
        # akka.remote.netty.tcp.port = 0
        # akka.remote.netty.tcp.bind-port = 0
        # Network interface will be bound to a random port, and remoting protocol will
        # expect messages sent to the bound port.
        #
        # akka.remote.netty.tcp.port = 2552
        # akka.remote.netty.tcp.bind-port = 0
        # Network interface will be bound to a random port, but remoting protocol will
        # expect messages sent to port 2552.
        #
        # akka.remote.netty.tcp.port = 0
        # akka.remote.netty.tcp.bind-port = 2553
        # Network interface will be bound to the 2553 port, and remoting protocol will
        # expect messages sent to the bound port.
        #
        # akka.remote.netty.tcp.port = 2552
        # akka.remote.netty.tcp.bind-port = ""
        # Network interface will be bound to the 2552 port, and remoting protocol will
        # expect messages sent to the bound port.
        #
        # akka.remote.netty.tcp.port if empty
        bind-port = ""

        # Use this setting to bind a network interface to a different hostname or ip
        # than remoting protocol expects messages at.
        # Use "0.0.0.0" to bind to all interfaces.
        # akka.remote.netty.tcp.hostname if empty
        bind-hostname = ""

        # Enables SSL support on this transport
        enable-ssl = false

        # Sets the connectTimeoutMillis of all outbound connections,
        # i.e. how long a connect may take until it is timed out
        connection-timeout = 15 s

        # If set to "<id.of.dispatcher>" then the specified dispatcher
        # will be used to accept inbound connections, and perform IO. If "" then
        # dedicated threads will be used.
        # Please note that the Netty driver only uses this configuration and does
        # not read the "akka.remote.use-dispatcher" entry. Instead it has to be
        # configured manually to point to the same dispatcher if needed.
        use-dispatcher-for-io = ""

        # Sets the high water mark for the in and outbound sockets,
        # set to 0b for platform default
        write-buffer-high-water-mark = 0b

        # Sets the low water mark for the in and outbound sockets,
        # set to 0b for platform default
        write-buffer-low-water-mark = 0b

        # Sets the send buffer size of the Sockets,
        # set to 0b for platform default
        send-buffer-size = 256000b

        # Sets the receive buffer size of the Sockets,
        # set to 0b for platform default
        receive-buffer-size = 256000b

        # Maximum message size the transport will accept, but at least
        # 32000 bytes.
        # Please note that UDP does not support arbitrary large datagrams,
        # so this setting has to be chosen carefully when using UDP.
        # Both send-buffer-size and receive-buffer-size settings has to
        # be adjusted to be able to buffer messages of maximum size.
        maximum-frame-size = 128000b

        # Sets the size of the connection backlog
        backlog = 4096

        # Enables the TCP_NODELAY flag, i.e. disables Nagle’s algorithm
        tcp-nodelay = on

        # Enables TCP Keepalive, subject to the O/S kernel’s configuration
        tcp-keepalive = on

        # Enables SO_REUSEADDR, which determines when an ActorSystem can open
        # the specified listen port (the meaning differs between *nix and Windows)
        # Valid values are "on", "off" and "off-for-windows"
        # due to the following Windows bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4476378
        # "off-for-windows" of course means that it's "on" for all other platforms
        tcp-reuse-addr = off-for-windows

        # Used to configure the number of I/O worker threads on server sockets
        server-socket-worker-pool {
          # Min number of threads to cap factor-based number to
          pool-size-min = 2

          # The pool size factor is used to determine thread pool size
          # using the following formula: ceil(available processors * factor).
          # Resulting size is then bounded by the pool-size-min and
          # pool-size-max values.
          pool-size-factor = 1.0

          # Max number of threads to cap factor-based number to
          pool-size-max = 2
        }

        # Used to configure the number of I/O worker threads on client sockets
        client-socket-worker-pool {
          # Min number of threads to cap factor-based number to
          pool-size-min = 2

          # The pool size factor is used to determine thread pool size
          # using the following formula: ceil(available processors * factor).
          # Resulting size is then bounded by the pool-size-min and
          # pool-size-max values.
          pool-size-factor = 1.0

          # Max number of threads to cap factor-based number to
          pool-size-max = 2
        }


      }

      netty.udp = ${akka.remote.netty.tcp}
      netty.udp {
        transport-protocol = udp
      }

      netty.ssl = ${akka.remote.netty.tcp}
      netty.ssl = {
        # Enable SSL/TLS encryption.
        # This must be enabled on both the client and server to work.
        enable-ssl = true

        security {
          # This is the Java Key Store used by the server connection
          key-store = "keystore"

          # This password is used for decrypting the key store
          key-store-password = "changeme"

          # This password is used for decrypting the key
          key-password = "changeme"

          # This is the Java Key Store used by the client connection
          trust-store = "truststore"

          # This password is used for decrypting the trust store
          trust-store-password = "changeme"

          # Protocol to use for SSL encryption, choose from:
          # TLS 1.2 is available since JDK7, and default since JDK8:
          # https://blogs.oracle.com/java-platform-group/entry/java_8_will_use_tls
          protocol = "TLSv1.2"

          # Example: ["TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA"]
          # You need to install the JCE Unlimited Strength Jurisdiction Policy
          # Files to use AES 256.
          # More info here:
          # http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider
          enabled-algorithms = ["TLS_RSA_WITH_AES_128_CBC_SHA"]

          # There are three options, in increasing order of security:
          # "" or SecureRandom => (default)
          # "SHA1PRNG" => Can be slow because of blocking issues on Linux
          # "AES128CounterSecureRNG" => fastest startup and based on AES encryption
          # algorithm
          # "AES256CounterSecureRNG"
          #
          # The following are deprecated in Akka 2.4. They use one of 3 possible
          # seed sources, depending on availability: /dev/random, random.org and
          # SecureRandom (provided by Java)
          # "AES128CounterInetRNG"
          # "AES256CounterInetRNG" (Install JCE Unlimited Strength Jurisdiction
          # Policy Files first)
          # Setting a value here may require you to supply the appropriate cipher
          # suite (see enabled-algorithms section above)
          random-number-generator = ""

          # Require mutual authentication between TLS peers
          #
          # Without mutual authentication only the peer that actively establishes a connection (TLS client side)
          # checks if the passive side (TLS server side) sends over a trusted certificate. With the flag turned on,
          # the passive side will also request and verify a certificate from the connecting peer.
          #
          # To prevent man-in-the-middle attacks you should enable this setting. For compatibility reasons it is
          # still set to 'off' per default.
          #
          # Note: Nodes that are configured with this setting to 'on' might not be able to receive messages from nodes that
          # run on older versions of akka-remote. This is because in older versions of Akka the active side of the remoting
          # connection will not send over certificates.
          #
          # However, starting from the version this setting was added, even with this setting "off", the active side
          # (TLS client side) will use the given key-store to send over a certificate if asked. A rolling upgrades from
          # older versions of Akka can therefore work like this:
          #   - upgrade all nodes to an Akka version supporting this flag, keeping it off
          #   - then switch the flag on and do again a rolling upgrade of all nodes
          # The first step ensures that all nodes will send over a certificate when asked to. The second
          # step will ensure that all nodes finally enforce the secure checking of client certificates.
          require-mutual-authentication = off
        }
      }

      ### Default configuration for the failure injector transport adapter

      gremlin {
        # Enable debug logging of the failure injector transport adapter
        debug = off
      }

      ### Default dispatcher for the remoting subsystem

      default-remote-dispatcher {
        type = Dispatcher
        executor = "fork-join-executor"
        fork-join-executor {
          parallelism-min = 2
          parallelism-factor = 0.5
          parallelism-max = 16
        }
        throughput = 10
      }

      backoff-remote-dispatcher {
        type = Dispatcher
        executor = "fork-join-executor"
        fork-join-executor {
          # Min number of threads to cap factor-based parallelism number to
          parallelism-min = 2
          parallelism-max = 2
        }
      }

    artery {

      # Enable the new remoting with this flag
      enabled = on

      # Canonical address is the address other clients should connect to.
      # Artery transport will expect messages to this address.
      canonical {

        # The default remote server port clients should connect to.
        # Default is 25520, use 0 if you want a random available port
        # This port needs to be unique for each actor system on the same machine.
        # port = 25520

        # Hostname clients should connect to. Can be set to an ip, hostname
        # or one of the following special values:
        #   "<getHostAddress>"   InetAddress.getLocalHost.getHostAddress
        #   "<getHostName>"      InetAddress.getLocalHost.getHostName
        #
        # hostname = "<getHostAddress>"
      }

      # Use these settings to bind a network interface to a different address
      # than artery expects messages at. This may be used when running Akka
      # nodes in a separated networks (under NATs or in containers). If canonical
      # and bind addresses are different, then network configuration that relays
      # communications from canonical to bind addresses is expected.
      bind {

        # Port to bind a network interface to. Can be set to a port number
        # of one of the following special values:
        #   0    random available port
        #   ""   akka.remote.artery.canonical.port
        #
        port = ""

        # Hostname to bind a network interface to. Can be set to an ip, hostname
        # or one of the following special values:
        #   "0.0.0.0"            all interfaces
        #   ""                   akka.remote.artery.canonical.hostname
        #   "<getHostAddress>"   InetAddress.getLocalHost.getHostAddress
        #   "<getHostName>"      InetAddress.getLocalHost.getHostName
        #
        hostname = ""
      }

      # Actor paths to use the large message stream for when a message
      # is sent to them over remoting. The large message stream dedicated
      # is separate from "normal" and system messages so that sending a
      # large message does not interfere with them.
      # Entries should be the full path to the actor. Wildcards in the form of "*"
      # can be supplied at any place and matches any name at that segment -
      # "/user/supervisor/actor/*" will match any direct child to actor,
      # while "/supervisor/*/child" will match any grandchild to "supervisor" that
      # has the name "child"
      # Messages sent to ActorSelections will not be passed through the large message
      # stream, to pass such messages through the large message stream the selections
      # but must be resolved to ActorRefs first.
      large-message-destinations = []

      # Enable untrusted mode, which discards inbound system messages, PossiblyHarmful and
      # ActorSelection messages. E.g. remote watch and remote deployment will not work.
      # ActorSelection messages can be enabled for specific paths with the trusted-selection-paths
      untrusted-mode = off

      # When 'untrusted-mode=on' inbound actor selections are by default discarded.
      # Actors with paths defined in this white list are granted permission to receive actor
      # selections messages.
      # E.g. trusted-selection-paths = ["/user/receptionist", "/user/namingService"]
      trusted-selection-paths = []

      # If this is "on", all inbound remote messages will be logged at DEBUG level,
      # if off then they are not logged
      log-received-messages = off

      # If this is "on", all outbound remote messages will be logged at DEBUG level,
      # if off then they are not logged
      log-sent-messages = off

      advanced {

        # Maximum serialized message size, including header data.
        maximum-frame-size = 256 KiB

        # Direct byte buffers are reused in a pool with this maximum size.
        # Each buffer has the size of 'maximum-frame-size'.
        # This is not a hard upper limit on number of created buffers. Additional
        # buffers will be created if needed, e.g. when using many outbound
        # associations at the same time. Such additional buffers will be garbage
        # collected, which is not as efficient as reusing buffers in the pool.
        buffer-pool-size = 128

        # Maximum serialized message size for the large messages, including header data.
        # See 'large-message-destinations'.
        maximum-large-frame-size = 2 MiB

        # Direct byte buffers for the large messages are reused in a pool with this maximum size.
        # Each buffer has the size of 'maximum-large-frame-size'.
        # See 'large-message-destinations'.
        # This is not a hard upper limit on number of created buffers. Additional
        # buffers will be created if needed, e.g. when using many outbound
        # associations at the same time. Such additional buffers will be garbage
        # collected, which is not as efficient as reusing buffers in the pool.
        large-buffer-pool-size = 32

        # For enabling testing features, such as blackhole in akka-remote-testkit.
        test-mode = off

        # Settings for the materializer that is used for the remote streams.
        materializer = ${akka.stream.materializer}

        # If set to a nonempty string artery will use the given dispatcher for
        # the ordinary and large message streams, otherwise the default dispatcher is used.
        use-dispatcher = "akka.remote.default-remote-dispatcher"

        # If set to a nonempty string remoting will use the given dispatcher for
        # the control stream, otherwise the default dispatcher is used.
        # It can be good to not use the same dispatcher for the control stream as
        # the dispatcher for the ordinary message stream so that heartbeat messages
        # are not disturbed.
        use-control-stream-dispatcher = ""

        # Controls whether to start the Aeron media driver in the same JVM or use external
        # process. Set to 'off' when using external media driver, and then also set the
        # 'aeron-dir'.
        embedded-media-driver = on

        # Directory used by the Aeron media driver. It's mandatory to define the 'aeron-dir'
        # if using external media driver, i.e. when 'embedded-media-driver = off'.
        # Embedded media driver will use a this directory, or a temporary directory if this
        # property is not defined (empty).
        aeron-dir = ""

        # Whether to delete aeron embeded driver directory upon driver stop.
        delete-aeron-dir = yes

        # Level of CPU time used, on a scale between 1 and 10, during backoff/idle.
        # The tradeoff is that to have low latency more CPU time must be used to be
        # able to react quickly on incoming messages or send as fast as possible after
        # backoff backpressure.
        # Level 1 strongly prefer low CPU consumption over low latency.
        # Level 10 strongly prefer low latency over low CPU consumption.
        idle-cpu-level = 5

        # WARNING: This feature is not supported yet. Don't use other value than 1.
        # It requires more hardening and performance optimizations.
        # Number of outbound lanes for each outbound association. A value greater than 1
        # means that serialization can be performed in parallel for different destination
        # actors. The selection of lane is based on consistent hashing of the recipient
        # ActorRef to preserve message ordering per receiver.
        outbound-lanes = 1

        # WARNING: This feature is not supported yet. Don't use other value than 1.
        # It requires more hardening and performance optimizations.
        # Total number of inbound lanes, shared among all inbound associations. A value
        # greater than 1 means that deserialization can be performed in parallel for
        # different destination actors. The selection of lane is based on consistent
        # hashing of the recipient ActorRef to preserve message ordering per receiver.
        inbound-lanes = 1

        # Size of the send queue for outgoing messages. Messages will be dropped if
        # the queue becomes full. This may happen if you send a burst of many messages
        # without end-to-end flow control. Note that there is one such queue per
        # outbound association. The trade-off of using a larger queue size is that
        # it consumes more memory, since the queue is based on preallocated array with
        # fixed size.
        outbound-message-queue-size = 3072

        # Size of the send queue for outgoing control messages, such as system messages.
        # If this limit is reached the remote system is declared to be dead and its UID
        # marked as quarantined.
        # The trade-off of using a larger queue size is that it consumes more memory,
        # since the queue is based on preallocated array with fixed size.
        outbound-control-queue-size = 3072

        # Size of the send queue for outgoing large messages. Messages will be dropped if
        # the queue becomes full. This may happen if you send a burst of many messages
        # without end-to-end flow control. Note that there is one such queue per
        # outbound association. The trade-off of using a larger queue size is that
        # it consumes more memory, since the queue is based on preallocated array with
        # fixed size.
        outbound-large-message-queue-size = 256

        # This setting defines the maximum number of unacknowledged system messages
        # allowed for a remote system. If this limit is reached the remote system is
        # declared to be dead and its UID marked as quarantined.
        system-message-buffer-size = 20000

        # unacknowledged system messages are re-delivered with this interval
        system-message-resend-interval = 1 second

        # The timeout for outbound associations to perform the handshake.
        # This timeout must be greater than the 'image-liveness-timeout'.
        handshake-timeout = 20 s

        # incomplete handshake attempt is retried with this interval
        handshake-retry-interval = 1 second

        # handshake requests are performed periodically with this interval,
        # also after the handshake has been completed to be able to establish
        # a new session with a restarted destination system
        inject-handshake-interval = 1 second

        # messages that are not accepted by Aeron are dropped after retrying for this period
        give-up-message-after = 60 seconds

        # System messages that are not acknowledged after re-sending for this period are
        # dropped and will trigger quarantine. The value should be longer than the length
        # of a network partition that you need to survive.
        give-up-system-message-after = 6 hours

        # during ActorSystem termination the remoting will wait this long for
        # an acknowledgment by the destination system that flushing of outstanding
        # remote messages has been completed
        shutdown-flush-timeout = 1 second

        # See 'inbound-max-restarts'
        inbound-restart-timeout = 5 seconds

        # Max number of restarts within 'inbound-restart-timeout' for the inbound streams.
        # If more restarts occurs the ActorSystem will be terminated.
        inbound-max-restarts = 5

        # See 'outbound-max-restarts'
        outbound-restart-timeout = 5 seconds

        # Max number of restarts within 'outbound-restart-timeout' for the outbound streams.
        # If more restarts occurs the ActorSystem will be terminated.
        outbound-max-restarts = 5

        # Stop outbound stream of a quarantined association after this idle timeout, i.e.
        # when not used any more.
        stop-quarantined-after-idle = 3 seconds

        # Timeout after which aeron driver has not had keepalive messages
        # from a client before it considers the client dead.
        client-liveness-timeout = 20 seconds

        # Timeout for each the INACTIVE and LINGER stages an aeron image
        # will be retained for when it is no longer referenced.
        # This timeout must be less than the 'handshake-timeout'.
        image-liveness-timeout = 10 seconds

        # Timeout after which the aeron driver is considered dead
        # if it does not update its C'n'C timestamp.
        driver-timeout = 20 seconds

        flight-recorder {
          // FIXME it should be enabled by default when we have a good solution for naming the files
          enabled = off
          # Controls where the flight recorder file will be written. There are three options:
          # 1. Empty: a file will be generated in the temporary directory of the OS
          # 2. A relative or absolute path ending with ".afr": this file will be used
          # 3. A relative or absolute path: this directory will be used, the file will get a random file name
          destination = ""
        }

        # compression of common strings in remoting messages, like actor destinations, serializers etc
        compression {

          actor-refs {
            # Max number of compressed actor-refs
            # Note that compression tables are "rolling" (i.e. a new table replaces the old
            # compression table once in a while), and this setting is only about the total number
            # of compressions within a single such table.
            # Must be a positive natural number.
            max = 256

            # interval between new table compression advertisements.
            # this means the time during which we collect heavy-hitter data and then turn it into a compression table.
            advertisement-interval = 1 minute # TODO find good number as default, for benchmarks trigger immediately
          }
          manifests {
            # Max number of compressed manifests
            # Note that compression tables are "rolling" (i.e. a new table replaces the old
            # compression table once in a while), and this setting is only about the total number
            # of compressions within a single such table.
            # Must be a positive natural number.
            max = 256

            # interval between new table compression advertisements.
            # this means the time during which we collect heavy-hitter data and then turn it into a compression table.
            advertisement-interval = 1 minute # TODO find good number as default, for benchmarks trigger immediately
          }
        }

        # List of fully qualified class names of remote instruments which should
        # be initialized and used for monitoring of remote messages.
        # The class must extend akka.remote.artery.RemoteInstrument and
        # have a public constructor with empty parameters or one ExtendedActorSystem
        # parameter.
        # A new instance of RemoteInstrument will be created for each encoder and decoder.
        # It's only called from the stage, so if it dosn't delegate to any shared instance
        # it doesn't have to be thread-safe.
        # Refer to `akka.remote.artery.RemoteInstrument` for more information.
        instruments = ${?akka.remote.artery.advanced.instruments} []
      }
    }
  }

  stream {

    # Default flow materializer settings
    materializer {

      # Initial size of buffers used in stream elements
      initial-input-buffer-size = 4
      # Maximum size of buffers used in stream elements
      max-input-buffer-size = 16

      # Fully qualified config path which holds the dispatcher configuration
      # to be used by FlowMaterialiser when creating Actors.
      # When this value is left empty, the default-dispatcher will be used.
      dispatcher = ""

      # Cleanup leaked publishers and subscribers when they are not used within a given
      # deadline
      subscription-timeout {
        # when the subscription timeout is reached one of the following strategies on
        # the "stale" publisher:
        # cancel - cancel it (via `onError` or subscribing to the publisher and
        #          `cancel()`ing the subscription right away
        # warn   - log a warning statement about the stale element (then drop the
        #          reference to it)
        # noop   - do nothing (not recommended)
        mode = cancel

        # time after which a subscriber / publisher is considered stale and eligible
        # for cancelation (see `akka.stream.subscription-timeout.mode`)
        timeout = 5s
      }

      # Enable additional troubleshooting logging at DEBUG log level
      debug-logging = off

      # Maximum number of elements emitted in batch if downstream signals large demand
      output-burst-limit = 1000

      # Enable automatic fusing of all graphs that are run. For short-lived streams
      # this may cause an initial runtime overhead, but most of the time fusing is
      # desirable since it reduces the number of Actors that are created.
      auto-fusing = on

      # Those stream elements which have explicit buffers (like mapAsync, mapAsyncUnordered,
      # buffer, flatMapMerge, Source.actorRef, Source.queue, etc.) will preallocate a fixed
      # buffer upon stream materialization if the requested buffer size is less than this
      # configuration parameter. The default is very high because failing early is better
      # than failing under load.
      #
      # Buffers sized larger than this will dynamically grow/shrink and consume more memory
      # per element than the fixed size buffers.
      max-fixed-buffer-size = 1000000000

      # Maximum number of sync messages that actor can process for stream to substream communication.
      # Parameter allows to interrupt synchronous processing to get upsteam/downstream messages.
      # Allows to accelerate message processing that happening withing same actor but keep system responsive.
      sync-processing-limit = 1000

      debug {
        # Enables the fuzzing mode which increases the chance of race conditions
        # by aggressively reordering events and making certain operations more
        # concurrent than usual.
        # This setting is for testing purposes, NEVER enable this in a production
        # environment!
        # To get the best results, try combining this setting with a throughput
        # of 1 on the corresponding dispatchers.
        fuzzing-mode = off
      }
    }

    # Fully qualified config path which holds the dispatcher configuration
    # to be used by FlowMaterialiser when creating Actors for IO operations,
    # such as FileSource, FileSink and others.
    blocking-io-dispatcher = "akka.stream.default-blocking-io-dispatcher"

    default-blocking-io-dispatcher {
      type = "Dispatcher"
      executor = "thread-pool-executor"
      throughput = 1

      thread-pool-executor {
        core-pool-size-min = 2
        core-pool-size-factor = 2.0
        core-pool-size-max = 16
      }
    }
  }

  # configure overrides to ssl-configuration here (to be used by akka-streams, and akka-http – i.e. when serving https connections)
  ssl-config {
    protocol = "TLSv1.2"
  }

}
